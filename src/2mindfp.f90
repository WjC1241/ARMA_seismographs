MODULE MINIMO
USE FUNCT

CONTAINS

SUBROUTINE MINDFP(P0,N,P,Q,Y,GTOL,ITER,FRET)!,FUNC,DFUNC)
IMPLICIT NONE
!!!!!!!!!!!!!!!!!!!!
!GIVEN A STARTING POINT P0(1:P+Q+1) THAT IS A VECTOR OF LENGTH P+Q+1, THE BROYDEN-FLETCHER-GOLDFARB-SHANNO VARIANT OF DAVIDON-FLETCHER-POWELL MINIMIZATION IS PERFORMED ON A FUNCTION FUNC, USING ITS GRADIENT AS CALCULATED BY A ROUTINE DFUNC. THE CONVERGENCE REQUIREMENT ON ZEROING THE GRADIENT IS INPUT AS GTOL. RETURNED QUANTITIES ARE P0(1:N) (THE LOCATION OF THE MINIMUM), ITER (THE NUMBER OF ITERATIONS THAT WERE PERFORMED), AND FRET (THE MINIMUM VALUE OF THE FUNCTION). THE ROUTINE LNSRCH IS CALLED TO PERFORM APPROXIMATE LINE MINIMIZATIONS. PARAMETERS: NMAX IS THE MAXIMUM ANTICIPATED VALUE OF N; ITMAX IS THE MAXIMUM ALLOWED NUMBER OF ITERATIONS; STPMX IS THE SCALED MAXIMUM STEP LENGTH ALLOWED IN LINE SEARCHES; TOLX IS THE CONVERGENCE CRITERION ON X VALUES.
!!!!!!!!!!!!!!!!!!!!
INTEGER, INTENT(IN):: N, P, Q
REAL*8,INTENT(INOUT):: P0(P+Q+1)
INTEGER,INTENT(OUT)::ITER
REAL*8, INTENT(OUT):: FRET
REAL*8,INTENT(IN):: GTOL, Y(1:N)
!REAL*8:: FUNC
INTEGER, PARAMETER :: NMAX=50,ITMAX=200,STPMX=100
REAL*8, PARAMETER:: EPS=3.D-8,TOLX=4.D0*EPS
INTEGER:: I, ITS, J
LOGICAL:: CHECK
REAL*8:: DEN,FAC,FAD,FAE,FP,STPMAX,SUMA,SUMDG,SUMXI,TEMP,TEST, DG(NMAX),G(NMAX),HDG(NMAX),HESSIN(NMAX,NMAX), PNEW(NMAX),XI(NMAX)
FP=FUNC(N,P,Q,Y,P0) 				!FUNCTION ON INITION POINT	
CALL DFUNC(N,P,Q,Y,P0,G)		!GRADIENT AT P_INITIAL 
SUMA=0D0
DO I=1, P+Q+1	!12		!INITIALIZE THE INVERSE HESSIAN TO THE UNIT MATRIX
	DO J=1, P+Q+1	!11
		HESSIN(I,J)=0.D0
	END DO !11
	HESSIN(I,I)=1.D0
	XI(I)=-G(I)			!INITIAL LINE DIRECTION.
	SUMA=SUMA+P0(I)**2
END DO !12
STPMAX=STPMX*DMAX1(DSQRT(SUMA),FLOAT(P+Q+1))
DO ITS=1,ITMAX !27			!MAIN LOOP OVER THE ITERATIONS.
	ITER=ITS
!THE NEW FUNCTION EVALUATION OCCURS IN LNSRCH; SAVE THE FUNCTION VALUE IN FP FOR THE NEXT LINE SEARCH. IT IS USUALLY SAFE TO IGNORE THE VALUE OF CHECK	
			!LNSRCH(N,P,Q,Y,XOLD,FOLD,G,P0,X,F,STPMAX,CHECK)!,FUNC)
	CALL LNSRCH(N,P,Q,Y,P0,FP,G,XI,PNEW,FRET,STPMAX,CHECK)!,FUNC)	
	FP=FRET
	DO I=1,P+Q+1 !13
		XI(I)=PNEW(I)-P0(I)		!UPDATE THE LINE DIRECTION,
		P0(I)=PNEW(I) 					!AND THE CURRENT POINT.
	ENDDO !13
	TEST=0.D0					!TEST FOR CONVERGENCE ON DELTA X.
	DO I=1,P+Q+1 !14
		TEMP=DABS(XI(I))/DMAX1(DABS(P0(I)),1.D0)
		IF(TEMP .GT. TEST) TEST=TEMP
	ENDDO !14
	IF(TEST .LT. TOLX) RETURN
	DO I=1,P+Q+1 !15 		!SAVE THE OLD GRADIENT,
		DG(I)=G(I)
	ENDDO !15
	CALL DFUNC(N,P,Q,Y,P0,G) 	!AND GET THE NEW GRADIENT.
	TEST=0.D0 				!TEST FOR CONVERGENCE ON ZERO GRADIENT.
	DEN=DMAX1(FRET,1.D0)
	DO I=1,P+Q+1 !16
		TEMP=DABS(G(I))*DMAX1(DABS(P0(I)),1.D0)/DEN
		IF(TEMP .GT. TEST) TEST=TEMP
	ENDDO !16
	IF(TEST .LT. GTOL) RETURN
	DO I=1,P+Q+1 !17		 		!COMPUTE DIFFERENCE OF GRADIENTS,
		DG(I)=G(I)-DG(I)
	ENDDO !17
	DO I=1,P+Q+1 !19 		!AND DIFFERENCE TIMES CURRENT MATRIX.
		HDG(I)=0.D0
		DO J=1,P+Q+1 !18
			HDG(I)=HDG(I)+HESSIN(I,J)*DG(J)
		ENDDO !18
	ENDDO !19
	FAC=0D0 					!CALCULATE DOT PRODUCTS FOR THE DENOMINATORS.
	FAE=0D0
	SUMDG=0D0
	SUMXI=0D0
	DO I=1,P+Q+1 !21
		FAC=FAC+DG(I)*XI(I)
		FAE=FAE+DG(I)*HDG(I)
		SUMDG=SUMDG+DG(I)**2
		SUMXI=SUMXI+XI(I)**2
	ENDDO !21
	IF(FAC .GT. DSQRT(EPS*SUMDG*SUMXI))THEN	!SKIP UPDATE IF FAC NOT SUFICIENTLY POSITIVE.
		FAC=1D0/FAC
		FAD=1D0/FAE
		DO I=1,P+Q+1 !22				!THEVECTOR THAT MAKES BFGS DIFFERENT FROM DFP:
			DG(I)=FAC*XI(I)-FAD*HDG(I)
		END DO !22
		DO I=1,P+Q+1 !24 			!THE BFGS UPDATING FORMULA:
			DO J=I,P+Q+1 !23
				HESSIN(I,J)=HESSIN(I,J)+FAC*XI(I)*XI(J)-FAD*HDG(I)*HDG(J)+FAE*DG(I)*DG(J)
				HESSIN(J,I)=HESSIN(I,J)
			END DO !23
		END DO !24
	ENDIF
	DO I=1,P+Q+1 !26 				!NOW CALCULATE THE NEXT DIRECTION TO GO,
		XI(I)=0D0
		DO J=1,P+Q+1 !25
			XI(I)=XI(I)-HESSIN(I,J)*G(J)
		END DO !25
	END DO !26
END DO !27							!AND GO BACK FOR ANOTHER ITERATION.
PRINT*, 'TOO MANY ITERATIONS IN MINDFP'
RETURN
END SUBROUTINE MINDFP
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!
SUBROUTINE LNSRCH(N,P,Q,Y,XOLD,FOLD,G,P0,X,F,STPMAX,CHECK)!,FUNC)
IMPLICIT NONE
INTEGER,INTENT(IN):: N, P, Q
LOGICAL,INTENT(OUT) :: CHECK
REAL*8,INTENT(IN):: XOLD(P+Q+1),FOLD,G(P+Q+1),Y(1:N)
REAL*8,INTENT(INOUT):: P0(1:P+Q+1)
REAL*8,INTENT(IN):: STPMAX
REAL*8,INTENT(OUT):: X(P+Q+1),F
!REAL*8 :: FUNC
REAL*8,PARAMETER :: ALF=1D-4,TOLX=1D-7
!GIVEN AN P+Q+1-DIMENSIONAL POINT XOLD(1:P+Q+1), THE VALUE OF THE FUNCTION AND GRADIENT THERE, FOLD AND G(1:P+Q+1), AND A DIRECTION P0(1:P+Q+1), FINDS A NEW POINT X(1:P+Q+1) ALONG THE DIRECTION P0 FROM XOLD WHERE THE FUNCTION FUNC HAS DECREASED “SUFFICIENTLY.” THE NEW FUNCTION VALUE IS RETURNED IN F. STPMAX IS AN INPUT QUANTITY THAT LIMITS THE LENGTH OF THE STEPS SO THAT YOU DO NOT TRY TO EVALUATE THE FUNCTION IN REGIONS WHERE IT IS UNDEFINED OR SUBJECT TO OVERFLOW. P IS USUALLY THE NEWTON DIRECTION. THE OUTPUT QUANTITY CHECK IS FALSE ON A NORMAL EXIT. IT IS TRUE WHEN X IS TOO CLOSE TO XOLD. IN A MINIMIZATION ALGORITHM, THIS USUALLY SIGNALS CONVERGENCE AND CAN BE IGNORED. HOWEVER, IN A ZERO-FINDING ALGORITHM THE CALLING PROGRAM SHOULD CHECK WHETHER THE CONVERGENCE IS SPURIOUS. PARAMETERS: ALF ENSURES SUFFICIENT DECREASE IN FUNCTION VALUE; TOLX IS THE CONVERGENCE CRITERION ON ∆X.
INTEGER :: I
REAL*8::A, ALAM, ALAM2, ALAMIN, B, DISC, F2, RHS1, RHS2, SLOPE, SUMA, TEMP, TEST, TMPLAM
CHECK=.FALSE.
SUMA=0D0
DO I=1,P+Q+1 !11
	SUMA=SUMA+P0(I)*P0(I)
ENDDO !11
SUMA=DSQRT(SUMA)
IF(SUMA .GT. STPMAX) THEN		!SCALE IF ATTEMPTED STEP IS TOO BIG.
	DO I=1,P+Q+1 !12
		P0(I)=P0(I)*STPMAX/SUMA
	ENDDO !12
ENDIF
SLOPE=0D0
DO I=1,P+Q+1 !13
	SLOPE=SLOPE+G(I)*P0(I)
ENDDO !13
IF(SLOPE .GE. 0D0) PRINT*, 'ROUNDOFF PROBLEM IN LNSRCH'
TEST=0D0										!COMPUTE Λ_MIN .
DO I=1,P+Q+1 !14
	TEMP=DABS(P0(I))/DMAX1(DABS(XOLD(I)),1D0)
	IF(TEMP .GT. TEST)	TEST=TEMP
ENDDO !14
ALAMIN=TOLX/TEST
ALAM=1D0								!ALWAYS TRY FULL NEWTON STEP FIRST.
1 CONTINUE							!START OF ITERATION LOOP.
	DO I=1,P+Q+1 !15
		X(I)=XOLD(I)+ALAM*P0(I)
	ENDDO !15
	F=FUNC(N,P,Q,Y,X) 
	IF(ALAM .LT. ALAMIN) THEN		!CONVERGENCE ON ∆X. FOR ZERO FINDING, THE CALLING PROGRAM SHOULD VERIFY THE CONVERGENCE.
		DO I=1,P+Q+1 !16						
			X(I)=XOLD(I)
		ENDDO !16
		CHECK=.TRUE.
		RETURN
	ELSE IF(F .LE. FOLD+ALF*ALAM*SLOPE) THEN	!SUFFICIENT FUNCTION DECREASE. (P0=X-XOLD)
		RETURN
	ELSE											!BACKTRACK.
		IF(ALAM .EQ. 1D0) THEN			!FIRST TIME.
			TMPLAM=-SLOPE/(2D0*(F-FOLD-SLOPE)) 
		ELSE										!SUBSEQUENT BACKTRACKS.
			RHS1=F-FOLD-ALAM*SLOPE
			RHS2=F2-FOLD-ALAM2*SLOPE	!F2=F(XOLD+ALAM2*P0)
			A=(RHS1/(ALAM**2)-RHS2/(ALAM2**2))/(ALAM-ALAM2)
			B=(-ALAM2*RHS1/(ALAM**2)+ALAM*RHS2/(ALAM2**2))/(ALAM-ALAM2)
			IF(A .EQ. 0D0) THEN
				TMPLAM=-SLOPE/(2D0*B)
			ELSE
				DISC=B*B-3D0*A*SLOPE	!DISCRIMINATING
				IF(DISC .LT. 0.D0) THEN
					TMPLAM=0.5D0*ALAM
				ELSE IF(B .LE. 0D0) THEN
					TMPLAM=(-B+DSQRT(DISC))/(3D0*A)
				ELSE
					TMPLAM=-SLOPE/(B+DSQRT(DISC))
				ENDIF
			ENDIF
			IF(TMPLAM .GT. 0.5D0*ALAM) TMPLAM=0.5D0*ALAM	!Λ ≤ 0.5*Λ_1.
		ENDIF
	ENDIF
	ALAM2=ALAM
	F2=F
	ALAM=DMAX1(TMPLAM,0.1D0*ALAM)								!Λ ≥ 0.1Λ_1 .
GOTO 1																		!TRY AGAIN.
END SUBROUTINE LNSRCH

END MODULE MINIMO
