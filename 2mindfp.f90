MODULE MINIMO
USE FUNCT

CONTAINS

SUBROUTINE MINDFP(P0,N,P,Q,Y,GTOL,ITER,FRET)
IMPLICIT NONE
INTEGER, INTENT(IN):: N, P, Q			!N: TAMAÑO DE LA MUESTRA TOMADA DE LA SERIE; P: ORDEN AUTO-REGRESIVO; Q: ORDEN DE MEDIA MÓVIL.
REAL*8,INTENT(INOUT):: P0(P+Q+1)	!PUNTO ARBITRARIO INICIAL Y PUNTO MÍNIMO QUE RETORNA EL ALGORITMO.
INTEGER,INTENT(OUT)::ITER					!NÚMERO DE ITERACIONES.					
REAL*8, INTENT(OUT):: FRET				!VALOR MÍNIMO DE LA FUNCIÓN.
REAL*8,INTENT(IN):: GTOL, Y(1:N)	!GTOL: REQUERIMIENTO DE CONVERGENCIA DEL GRADIENTE. Y: SERIE TEMPORAL SÍSMICA ORIGINAL.
INTEGER, PARAMETER :: NMAX=50,ITMAX=200,STPMX=100	!NMAX: NÚMERO MÁXIMO DE PARÁMETROS A OPTIMIZAR. ITMAX: NÚMERO MÁXIMO DE ITERACIONES. STPMAX: LONGITUD MÁXIMA DEL PASO ESCALADO PERMITIDO.
REAL*8, PARAMETER:: EPS=3.D-8,TOLX=4.D0*EPS	!CRITERIOS DE CONVERGENCIA DE LA FUNCIÓN.
INTEGER:: I, ITS, J
LOGICAL:: CHECK
REAL*8:: DEN,FAC,FAD,FAE,FP,STPMAX,SUMA,SUMDG,SUMXI,TEMP,TEST, DG(NMAX),G(NMAX),HDG(NMAX),HESSIN(NMAX,NMAX), PNEW(NMAX),XI(NMAX)
FP=FUNC(N,P,Q,Y,P0) 			!FUNCIÓN EVALUADA EN EL PUNTO INICIAL.	
CALL DFUNC(N,P,Q,Y,P0,G)	!GRADIENTE EN EL PUNTO INICIAL.
SUMA=0D0
DO I=1, P+Q+1	!12		!CÁLCULO MATRIZ UNIDAD.
	DO J=1, P+Q+1	!11
		HESSIN(I,J)=0.D0
	END DO !11
	HESSIN(I,I)=1.D0
	XI(I)=-G(I)			!DIRECCIÓN INICIAL.
	SUMA=SUMA+P0(I)**2
END DO !12
STPMAX=STPMX*DMAX1(DSQRT(SUMA),FLOAT(P+Q+1))
DO ITS=1,ITMAX !27			!LAZO PRINCIPAL SOBRE LAS ITERACIONES.
	ITER=ITS	
	!LA EVALUACIÓN DE FUNCIONES OCURRE EN LNSRCH; EL VALOR DE LA FUNCIÓN SE GUARDA EN FP PARA VOLVER A LLAMAR A LNSRCH.
			!LNSRCH(N,P,Q,Y,XOLD,FOLD,G,P0,X,F,STPMAX,CHECK)
	CALL LNSRCH(N,P,Q,Y,P0,FP,G,XI,PNEW,FRET,STPMAX,CHECK)
	FP=FRET
	DO I=1,P+Q+1 !13
		XI(I)=PNEW(I)-P0(I)	!ACTUALIZACIÓN DE LA DIRECCIÓN,
		P0(I)=PNEW(I) 	!Y DEL PUNTO EN EL ESPACIO DE PARÁMETROS.
	ENDDO !13
	TEST=0.D0					!TEST DE LA CONVERGENCIA DE DELTA X.
	DO I=1,P+Q+1 !14
		TEMP=DABS(XI(I))/DMAX1(DABS(P0(I)),1.D0)
		IF(TEMP .GT. TEST) TEST=TEMP
	ENDDO !14
	IF(TEST .LT. TOLX) RETURN
	DO I=1,P+Q+1 !15 			!GUARDAR EL GRADIENTE ANTERIOR,
		DG(I)=G(I)
	ENDDO !15
	CALL DFUNC(N,P,Q,Y,P0,G) 	!Y EL NUEVO GRADIENTE.
	TEST=0.D0					!TEST DE LA CONVERGENCIA DEL GRADIENTE.
	DEN=DMAX1(FRET,1.D0)
	DO I=1,P+Q+1 !16
		TEMP=DABS(G(I))*DMAX1(DABS(P0(I)),1.D0)/DEN
		IF(TEMP .GT. TEST) TEST=TEMP
	ENDDO !16
	IF(TEST .LT. GTOL) RETURN	!INICIO CORRECCIÓN BFGS.
	DO I=1,P+Q+1 !17		 	!DIFERENCIA ENTRE GRADIENTES,
		DG(I)=G(I)-DG(I)
	ENDDO !17
	DO I=1,P+Q+1 !19 			!Y DIFERENCIA ENTRE MATRICES.
		HDG(I)=0.D0
		DO J=1,P+Q+1 !18
			HDG(I)=HDG(I)+HESSIN(I,J)*DG(J)
		ENDDO !18
	ENDDO !19
	FAC=0D0 					!PRODUCTO DE LOS DENOMINADORES.
	FAE=0D0
	SUMDG=0D0
	SUMXI=0D0
	DO I=1,P+Q+1 !21
		FAC=FAC+DG(I)*XI(I)
		FAE=FAE+DG(I)*HDG(I)
		SUMDG=SUMDG+DG(I)**2
		SUMXI=SUMXI+XI(I)**2
	ENDDO !21
	IF(FAC .GT. DSQRT(EPS*SUMDG*SUMXI))THEN	!SI FAC NO ES SUFICIENTEMENTE POSITIVO, SALTAR ACTUALIZACIÓN.
		FAC=1D0/FAC
		FAD=1D0/FAE
		DO I=1,P+Q+1 !22		!VECTOR QUE CORRIGE EL PLANTEAMIENTO DE DFP.
			DG(I)=FAC*XI(I)-FAD*HDG(I)
		END DO !22
		DO I=1,P+Q+1 !24		!FÓRMULA DE BFGS:
			DO J=I,P+Q+1 !23
				HESSIN(I,J)=HESSIN(I,J)+FAC*XI(I)*XI(J)-FAD * HDG(I)*HDG(J)+FAE*DG(I)*DG(J)
				HESSIN(J,I)=HESSIN(I,J)
			END DO !23
		END DO !24
	ENDIF
	DO I=1,P+Q+1 !26 			!CÁLCULO DE LA NUEVA DIRECCIÓN A SEGUIR.
		XI(I)=0D0
		DO J=1,P+Q+1 !25
			XI(I)=XI(I)-HESSIN(I,J)*G(J)
		END DO !25
	END DO !26
END DO !27							!REGRESO A EMPEZAR OTRA ITERACIÓN.
PRINT*, 'NÚMERO MÁXIMO DE ITERACIONES ALCANZADO'
RETURN
END SUBROUTINE MINDFP
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!
!!!!!!!!!!
SUBROUTINE LNSRCH(N,P,Q,Y,XOLD,FOLD,G,P0,X,F,STPMAX,CHECK)
IMPLICIT NONE
INTEGER,INTENT(IN):: N, P, Q	!TAMAÑO DE LA SERIE TEMPORAL, ORDEN AUTO-REGRESIVO Y ORDEN DE MEDIA MÓVIL RESPECTIVAMENTE.
LOGICAL,INTENT(OUT) :: CHECK
REAL*8,INTENT(IN):: XOLD(P+Q+1),FOLD,G(P+Q+1),Y(1:N)	!XOLD ES EL PUNTO INICIAL; FOLD (FUNCIÓN) Y G (GRADIENTE) EVALUADOS EN XOLD; Y(N) ES LA SERIE TEMPORAL.
REAL*8,INTENT(INOUT):: P0(1:P+Q+1)	!DIRECCIÓN DE NEWTON.
REAL*8,INTENT(IN):: STPMAX	!CANTIDAD QUE LIMITA LA LONGITUD DE LOS PASOS.
REAL*8,INTENT(OUT):: X(P+Q+1),F		!X NUEVO PUNTO A LO LARGO DE LA DIRECCIÓN; F VALOR DE LA FUNCIÓN QUE RETORNA.
REAL*8,PARAMETER :: ALF=1D-4,TOLX=1D-7	!ALF ASEGURA UNA DISMINUCIÓN SUFICIENTE EN EL VALOR DE LA FUNCIÓN; TOLX ES LA CONVERGENCIA CRITERIO SOBRE DELTA X.
INTEGER :: I
REAL*8::A, ALAM, ALAM2, ALAMIN, B, DISC, F2, RHS1, RHS2, SLOPE, SUMA, TEMP, TEST, TMPLAM
CHECK=.FALSE.
SUMA=0D0
DO I=1,P+Q+1 !11
	SUMA=SUMA+P0(I)*P0(I)
ENDDO !11
SUMA=DSQRT(SUMA)
IF(SUMA .GT. STPMAX) THEN		!REESCALAMIENTO SI EL PASO ES MUY LARGO.
	DO I=1,P+Q+1 !12
		P0(I)=P0(I)*STPMAX/SUMA
	ENDDO !12
ENDIF
SLOPE=0D0
DO I=1,P+Q+1 !13
	SLOPE=SLOPE+G(I)*P0(I)
ENDDO !13
IF(SLOPE .GE. 0D0) PRINT*, 'LNSRCH: LA DIRECCIÓN SEGUIDA NO MINIMIZA LA FUNCIÓN'
TEST=0D0			!CÁLCULO DEL VALOR MÍNIMO DEL ENTERO POSITIVO S.
DO I=1,P+Q+1 !14
	TEMP=DABS(P0(I))/DMAX1(DABS(XOLD(I)),1D0)
	IF(TEMP .GT. TEST)	TEST=TEMP
ENDDO !14
ALAMIN=TOLX/TEST
ALAM=1D0			!PRIMERO SE INTENTA EL PASO DE NEWTON COMPLETO.
1 CONTINUE			!INICIO DE LAZO DE ITERACIÓN.
	DO I=1,P+Q+1 !15
		X(I)=XOLD(I)+ALAM*P0(I)
	ENDDO !15
	F=FUNC(N,P,Q,Y,X) 
	IF(ALAM .LT. ALAMIN) THEN		!CONVERGENCIA EN DELTA X.
		DO I=1,P+Q+1 !16						
			X(I)=XOLD(I)
		ENDDO !16
		CHECK=.TRUE.
		RETURN
	ELSE IF(F .LE. FOLD+ALF*ALAM*SLOPE) THEN	!CRITERIO DE DECRECIMIENTO DE LA FUNCIÓN, (P0=X-XOLD).
		RETURN
	ELSE							!RETROCESO.
		IF(ALAM .EQ. 1D0) THEN	!PRIMERA VEZ QUE SE RETROCEDE.
			TMPLAM=-SLOPE/(2D0*(F-FOLD-SLOPE)) 
		ELSE						!SIGUIENTES RETROCESOS.
			RHS1=F-FOLD-ALAM*SLOPE
			RHS2=F2-FOLD-ALAM2*SLOPE	!F2=F(XOLD+ALAM2*P0)
			A=(RHS1/(ALAM**2)-RHS2/(ALAM2**2))/(ALAM-ALAM2)
			B=(-ALAM2*RHS1/(ALAM**2)+ALAM*RHS2/(ALAM2**2))/(ALAM-ALAM2)
			IF(A .EQ. 0D0) THEN
				TMPLAM=-SLOPE/(2D0*B)
			ELSE
				DISC=B*B-3D0*A*SLOPE	!DISCRIMINANTE.
				IF(DISC .LT. 0.D0) THEN
					TMPLAM=0.5D0*ALAM
				ELSE IF(B .LE. 0D0) THEN
					TMPLAM=(-B+DSQRT(DISC))/(3D0*A)
				ELSE
					TMPLAM=-SLOPE/(B+DSQRT(DISC))
				ENDIF
			ENDIF
			IF(TMPLAM .GT. 0.5D0*ALAM) TMPLAM=0.5D0*ALAM	!S <= 0.5*S_1.
		ENDIF
	ENDIF
	ALAM2=ALAM
	F2=F
	ALAM=DMAX1(TMPLAM,0.1D0*ALAM)		!S >= 0.1 S_1 .
GOTO 1							!INICIO DEL NUEVO LOOP.
END SUBROUTINE LNSRCH

END MODULE MINIMO
